JavaScript 随着 Node 的出现，极大的扩大了应用场景，在服务器端的编程领域，在海量请求与长时间运行的前提下，需要进行内存控制，对于性能敏感的服务端程序，对内存管理也有一定的要求。

V8 是 Chrome 与 Node 中的 JavaScript 运行时，JavaScript 对象都是通过 V8 进行分配和管理的。

## V8 的内存限制

- 64 位系统：约 1.4 GB
- 32 位系统：约 0.7 GB

**node 中查看 v8 中的内存使用量**
```js
process.memoryUsage() // {rss: ..., heapTotal: ..., heapUsed: ...}
```
**node 服务启动时调整 V8 的内存限制**
```bash
node --max-old-space-size=1700 test.js # 单位为 MB
node --max-new-space-size=1024 test.js # 单位为 KB
```
**V8 限制对内存的原因**

v8 最初是为浏览器设计的，网页开发中一般不会有用到大量内存的场景，V8 的内存限制下运行已绰绰有余。
此外，按官方说法，以 1.5 GB 的垃圾回收堆内存为例，一次小的垃圾回收需要 50 毫秒以上，做一次非增量式的垃圾回收甚至需要 1 秒以上，垃圾回收会阻塞 JavaScript 代码的执行，在这样时间开销下，应用的性能与响应能力直线下降，故而直接限制对内存来保障性能与响应能力。

## V8 的分代垃圾回收机制

在自动垃圾回收的演变过程中，人们发现没有一种算法可以胜任所有场景。在 V8 中根据实际对象生存周期的长短采用不同的算法。

在 V8 中主要基于分代式的垃圾回收机制，将内存分为新生代存储区和老生代存储区。

**新生代存储区**由两个 `reserved_semispace_size_`（64位：16MB，32位：8MB）构成。

**老生代存储区**默认为，64位：1400MB，32位：700MB

V8 内存的最大保留空间为 `4 * reserved_semispace_size_ + max_old_generation_size_`

### 新生代（Scavenge算法）

在分代的基础上，新生代存储区主要通过 Scavenge 算法进行垃圾回收

Scavenge 算法是基于复制方式实现的。它将新生代内存一分为二（两个 semispace），其中一个 semispace 内存空间处于使用状态（From 空间），另一个处于闲置状态（To 空间）。
分配对象时，会将其先分配到 From 空间，垃圾回收时，会检查 From 空间的对象，将存活对象复制到 To 空间，完成 From 空间所有对象的检查与存活对象复制后，将 From 空间与 To 空间角色对换（本质为释放非存活对象的内存）

**对象由新生代晋升到老生代**

触发**晋升**的条件主要有两个：
1. 对象是否经历过 Scavenge 回收
2. To 空间使用超过 25%

*新生代中对象的生命周期较短、存活对象较少，因而适合这种牺牲空间换时间的算法*
### 老生代（Mark-Sweep&Mark-Compact）

