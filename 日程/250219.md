
## 笔记

赋值表达式操作本身的结果为**右操作数的值**

**????全局变量的管理方式??**

**????在 JavaScript 中，一切都是表达式，一切都是运算??**

词法错误、语法错误均会导致当前文件模块中 `import` 的文件模块不会下载

在 JavaScript 语言的设计上，除了那些预设的标点符号（例如大括号、运算符之类），以及部分的保留字和关键字之外，事实上用户代码可以书写的只有三种东西。这包括：
- 标识符：（通常是）一个名字；
- 字面量：表明由它的字面含义所决定的一个值；
- 模板：一个可计算结果的字符串值。
所以，如果在这个层面上解构一份你所书写的 JavaScript 代码，那么**所能书写 / 声明的，就一定只有名字和值**
export 事实上就只能导出“名字和值”。然而一旦它能导出“名字和值”，也就意味着它能导出一个模块中的“全部内容”，

在处理 export/import 语句的全程，没有表达式被执行！

所谓**模块的装配**过程，就是执行一次**顶层代码**而已。

没有模块会导出（传统意义上的）main()，因为 ECMAScript 为了维护模块的静态语义，而把执行过程及其入口的定义丢回给了引擎或宿主本身。


---

语句，是 JavaScript 中组织代码的**基本语法组件**
JavaScript 中的**执行逻辑**有**顺序**、**循环**、**分支**

从语言设计的原则上来看，越少作用域的执行环境调度，效率越高、执行时性能越好

基于这个原则，switch语句被设计为有且仅有一个作用域，无论它有多少个 case 语句，其实都是运行在一个块级作用域环境中的。

所谓“块级作用域”，本质上只包括一组标识符。因此，只有当存在潜在标识符冲突的时候，才有必要新添加一个作用域来管理它们

在语言设计时，有三种需求会促使**语句构建自己的作用域**，标识符管理只是其中之一。其它两种情况，要么是因为在语法上支持多语句（例如 try...catch..finally 语句），要么是语句所表达的语义要求有一个块，例如“块语句{ }”在语义上就要求它自己是一个块级作用域。