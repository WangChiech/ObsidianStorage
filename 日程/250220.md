
## 笔记

[JavaScrip 核心原理-极客时间-周爱民](https://time.geekbang.org/column/article/169584?utm_campaign=geektime_search&utm_content=geektime_search&utm_medium=geektime_search&utm_source=geektime_search&utm_term=geektime_search)

表达式可以引用上下文中的其他变量

真正了解 JavaScript 语言：语言是什么，它长得怎么样，它为什么长成这个样子，它如何成长、长大、又或者变化的。对于语言来说，它的生命的原点在哪里？原动力又在哪里？
贯通整个 JavaScript 语言的构造过程，了解所有的语法、词法，以及引擎内核结构的设计原理与应用原则

构建自己的语言学习体系

代码是你的架构表现方式，仅此而已

“引用其实也是数据，可以理解为指向数据的数据”。赞的。回想一下指针，其实是在《数据结构》这门课中讲的。：）所以没错，引用也是数据。它不单单是数据的表现或指向，其本身也是数据。
1）**数据要么来自于声明，要么来自于计算。**前者是环境的（静态的），后者是执行过程的（动态的）。
2）**数据只有在环境中，才能被执行过程之外的逻辑使用。**——想一下CPU就理解了，如果`ADD AX, 4`可以直接送入CPU求值，但它的结果要么在“CPU的寄存器”中，要么送回内存（这里相当于环境）。所以的语言行为追溯到机器指令一级，都将是一致的逻辑：指令 + 数据。

JavaScript 没有 GOTO 语句了。取而代之的，是**分块代码**，以及**基于代码分块的流控制技术**。这些控制逻辑基于一个简单明了的原则：如果代码分块中需要 GOTO 的逻辑，那么就为它设计一个”自己的 GOTO“

通过“作用域”来管理代码的确很好，但是作用域与“语句的位置”以及“GOTO 到新的程序执行”这样的理念是矛盾的。它们并不在同一个**语义系统**内，这也是标签与变量可以重名而不相互影响的根本原因。由于这个原因，在使用标签的代码上下文中，**执行现场的回收**就与传统的“块”以及“块级作用域”根本上不同。

函数的RETURN要与参数结合起来理解，就是一进一出的求值=>数据传递方式。——多说一句，yield带来的是多进多出的数据传递。

表达式执行（包括函数执行），本质上都是求值运算，所以它们应当只返回值。但是事实上所有的执行——包括函数、表达式和语句也都“同时”是可以返回完成状态，这样才能在表达式中向外抛异常，因为异常抛出就是一个完成状态。 但是ECMAScript对所有在表达式层面上返回的“完成状态”做了处理，相当于在语言层面上“消化了”这些状态。所以绝大多数情况下，你认为表达式执行返回的Result是值或引用就好了。稍有例外的是，函数调用返回的是一个type为Return的完成状态，只不过它在内部方法Call处理之后，也已经变成了值而已。

```js
const obj = { foo() { return this === obj } }

(function () { return obj.foo })()() // 抛出异常，因为return不能返回引用，函数名标识符引用类型能调用，值类型不能调用
```

严格来说，有且只有“可执行结构”才具有执行上下文，并且只有“执行上下文”才需要通过“出入栈”来在引擎中调度。所谓“作用域”实际映射的是“环境”，环境可以通过outer域来指向外层环境，从而形成一个反向查找的链。每个执行上下文持有一个（实际是两个）这样的环境链，并且在执行过程中，随着作用域的展开而展开这个链，当离开某个作用域的时候就从链上反向顺着outer查找，直到找到这个作用域的外层。


在引擎中，return发生时，并不是“立即”清理栈并退出函数（这与我们大多数人想像的并不一样）。在引擎里，对于'try .. finally ..'这个结构来说，return实际是try {}这里的语句块的“语句执行结果”。——也就是说，把try块中的代码按行执行，到最后一行的结果B（Result，Completion Record，完成状态）。这个完成记录B的type是RETURN。然后，引擎回到try{}块并处理finally{}块。然后忽略掉finally块的完成记录F（如果这个记录F的类型是normal的话），用try{}中的返回。——但是，如果F的类型是RETURN、THROW、BREAK等，那么它就会使用F的结果值来返回了。
  
这段逻辑在： https://tc39.es/ecma262/#sec-try-statement-runtime-semantics-evaluation 
```
TryStatement : try Block Finally 
------ 
1. Let B be the result of evaluating Block. 
2. Let F be the result of evaluating Finally. 
3. If F.[[Type]] is normal, set F to B. 
4. Return ? UpdateEmpty(F, undefined). 
```
```js
function testBlock () { 
	let t = 1; 
	try { 
		t = 2; 
		return t; // t 会在执行 finally 之前作为单值表达式先被求值计算，，然后进入finally块，然后再处理return 语义来返回
	} 
	finally { t = 3 } 
} 
console.log(testBlock()) //输出为2
```

所有特殊可执行结构其实都是来自于某种固定的、确定的逻辑。这些逻辑语义是非常明确的，输入输出都很确定，这样才能被设计成一个标准的、易于理解的可执行结构。

任何实际参数在传入一个函数的形式参数时，都会经历这样的一个执行过程，它是**将函数实例化**这个内部行为的一个处理阶段
**所谓将函数实例化就是将函数从源代码文本变成一个可以执行的、运行期的闭包的过程**。

---
教而不明其法，学而不得其道

---

